JAVA SCRIPT
VAR 2-JS   5/5

# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie function `bowdlerize(input, dictionary)` unde:
- un obiect `Duck` este construit pe baza unui nume de tip string sau String
- un `Duck` poate sa inoate
- un `RubberDuck` poate sa pluteasca
- un `RubberDuck` nu poate sa inoate

# Completati urmatoarele taskuri:
- `name` trebuie sa fie de tip `string` sau `String`. Daca este furnizat alt tip este aruncat `Error` cu mesajul`name must be string or String`; (0.5 pts)
- daca i se cere unui obiect Duck sa inoate va returna un string (ex. daca avem un Duck cu numele `Donald` atunci string-ul returnat este `Donald is swimming`); (0.5 pts)
- o rata de cauciuc este atat de tip `Duck` cat si `RubberDuck`; (0.5 pts)
- daca i se cere unui obiect RubberDuck sa pluteasca va returna un string (ex. daca avem un RubberDuck cu numele `Donald` atunci string-ul returnat este `Donald floats`); (0.5 pts)
- daca i se cere unui obiect RubberDuck sa inoate va returna un string (ex. daca avem un RubberDuck cu numele `Donald` atunci string-ul returnat este `Donald can't swim, only float`); (0.5 pts)


class Duck {
    constructor(name) {
	//cerinta 1
        if (typeof name === 'string' || typeof name === String) {
            this.name = name
        }
        else throw new Error(`name must be string or String`)
    }
    move() {
        return `${this.name} is moving`
    }

    swim() {
        return `${this.name} is swimming`
    }
}

class RubberDuck extends Duck{
    constructor(name){
        super(name)
    }

    float() {
        return `${this.name} floats`
    }

    swim() {
        return `${this.name} can't swim, only float`
    }
}

const app = {
    Duck,
    RubberDuck
}

module.exports = app

 2)  Var 2 Alice 5/5 sau examen Robert
# Subiect 2 (2.5 pts)     
# Tematica: Javascript

# Avand clasa `Queue` din fisierul `index.js` sa se implementeze urmatoarele functionalitati: 
- clasa `Queue` trebuie sa contina o proprietate numita `items`, de tip `Array` care va fi initializata cu un vector gol (0.5 pts);
- se va implementa metoda `insert` ce va primi ca parametru un `element` care va fi adaugat in vector, conform principiului cozii;
- metoda `insert` va permite adaugarea in coada doar a elementelor de tip `string` si va arunca o eroare cu textul `Invalid Type` pentru elementele de alt tip.
- se va implementa metoda `extract` ce va returna un `element` din vector, conform principiului cozii;
- in cazul in care vectorul este gol si se apeleaza metoda `extract`, se va 
arunca o eroare cu textul `Invalid Operation`;

class Queue {
    constructor() {
        this.items = []
    }

    insert = (element) => {
        if (typeof element === 'string') {
            this.items.push(element)
        }
        else throw new Error('Invalid Type')
    }

    extract = () => {
        if (this.items.length > 0) {
            return this.items.shift()
        }
        else throw new Error(`Invalid Operation`)
    }
}

module.exports = Queue;

3)JS ANA V0 5/5
# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie function `bowdlerize(input, dictionary)` unde:
- `input` este un string (ex. "This is a cat")
- `dictionary` este un vector ce contine o serie de string-uri.

# Completati urmatoarele taskuri:
- `input` trebuie sa fie de tip `string`. Daca este dat un input de alt tip se va arunca un `Error` cu mesajul `Input should be a string`; (0.5 pts)
- `dictionary` este un vector de elemente de tip `string`. Daca cel putin un element nu este `string` se va arunca un `Error` cu mesajul `Invalid dictionary format`; (0.5 pts)
- Daca `dictionary` contine cuvinte, vor fi inlocuite in `input` cu prima litera, urmatÄƒ de  o serie de caractere `*` urmate de ultima litera. Lungimea cuvantului rezultat este acceasi ca a celui initial (ex. 'test' va deveni 't**t') ; (0.5 pts)
- Se va returna un nou string, `input` nefiind modificat; (0.5 pts)
- Functia returneaza rezultatul corect si pentru cuvinte care incep cu litere mari. (0.5 pts)

function bowdlerize(input, dictionary){
    if(typeof input!=='string'){
        throw new Error('Input should be a string')
    }

    var inputCopy = input
    dictionary.forEach(element => {

        if (typeof element !== 'string') {
            throw "Invalid dictionary format"
        }

        //prima litera din cuvant toUpperCase
        var element2 = element.charAt(0).toUpperCase() + element.slice(1)
        //daca inputul
        if(inputCopy.includes(element)){
            //despart pe litere
            let letters = element.split('')
            let str = ''
            letters.forEach(letter => {
                //daca litera e pe pozitia de inceput sau pe ultima pozitie, o adaugam la cuvantul modificat
                if (letter.toLowerCase() === letters[0].toLowerCase() || letter.toLowerCase() === letters[letters.length - 1].toLowerCase()) {
                    str += letter
                }
                else {
                    //altfel adaugam * la cuvantul modificat
                    str += '*'
                }
            })
            inputCopy = inputCopy.replace(element, str)
        }
        else{
            //daca include cuvant cu majuscula
            if(inputCopy.includes(element2)){
                let letters = element2.split('')
                let str = ''
                letters.forEach(letter => {
                    if (letter.toLowerCase() === letters[0].toLowerCase() || letter.toLowerCase() === letters[letters.length - 1].toLowerCase()) {
                        str += letter
                    }
                    else {
                        str += '*'
                    }
                })
                inputCopy = inputCopy.replace(element2, str)
            }
        }
    });

    return inputCopy
}

const app = {
    bowdlerize
};

module.exports = app;

4) JS ANA V1 5/5 sau Andrei V1
# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie function `calculateFrequencies(input, stopWords)` unde:
- `input` este un string sau un obiect String (ex. "This is a cat")
- `stopWords` este un vector ce contine o serie de string-uri sau obiecte String.

# Completati urmatoarele taskuri:
- `input` trebuie sa fie de tip `string` sau `String`. Daca este dat un input de alt tip se va arunca un `Error` cu mesajul `Input should be a string`; (0.5 pts)
- `dictionary` este un vector de elemente de tip `string` sau `String`. Daca cel putin un element nu este `string` se va arunca un `Error` cu mesajul `Invalid dictionary format`; (0.5 pts)
- functia calculeaza frecventele relative ale cuvintelor in input si returneaza un dictionar care are cuvintele drept chei si frecventele drept valori (ex. pentru string-ul 'orange cat' rezultatul va fi {orange : 0.5, cat : 0.5}); (0.5 pts)
- daca stopWords contine cuvinte, ele vor fi ignorate pentru calcularea frecventelor (ex. pentru 'the orange cat' cu 'the' in stopWords rezultatul va fi {orange : 0.5, cat : 0.5}); (0.5 pts)
- functia returneaza rezultatul corect si pentru cuvinte care incep cu o litera mare, care sunt considerate identice cu varianta fara litera mare. (0.5 pts)

function calculateFrequencies(input, dictionary) {
    if (typeof input !== 'string' && typeof input !== 'String') {
        throw "Input should be a string"
    }

    dictionary.forEach(element => {
        if (typeof element !== 'string' && typeof element !== 'String') {
            throw "Invalid dictionary format"
        }
    })

    //despart inputul (text) in cuvinte
    input = input.split(' ')
    dictionary.forEach(word => {
        input.forEach(element => {
            if (element.toLowerCase() === word.toLowerCase()) {
                //sterge elementul din input
                input.splice(input.indexOf(element), 1)
            }
        })
    })

    let obj = {}

    input.forEach(word => {
        if (!obj.hasOwnProperty(word.toLowerCase())) {
            obj[word.toLowerCase()] = 1
        }
        else {
            obj[word.toLowerCase()]++
        }
    })

    for (pr in obj) {
        obj[pr] = obj[pr] / input.length
    }
    return obj

}

const app = {
    calculateFrequencies
};

module.exports = app;


5)JS Ana V4 5/5
# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie  `removeOrderItem(orderInfo, position)` unde:
- `orderInfo` este un obiect cu proprietatile total si items
- `position` este un numar intreg ce determina un element din items

# Completati urmatoarele taskuri:
- validati proprietatea `items` sa fie de tip `array`. Daca este dat un input de alt tip se va arunca eroare cu mesajul `Items should be an array`; (0.5 pts)
- fiecare obiect din `items` este are proprietatile price si quantity. Daca cel putin un element nu respecta formatul se va arunca mesajul `Malformed item`; (0.5 pts)
- parametrul `position` este valid in relatie cu vectorul items (0.5 pts)
- se va returna obiectul orderInfo din care s-a eliminat elementul de pe pozitia data (0.5 pts)
- functia returneaza totalul corect pentru comanda in urma eliminarii elementului de pe pozitia data. (0.5 pts)

function removeOrderItem(orderInfo, position){
    if(!Array.isArray(orderInfo.items)){
        throw 'Items should be an array';
    }
    
    orderInfo.items.forEach(element=>{
    if(!(element.hasOwnProperty('price'))||!(element.hasOwnProperty('quantity')))
    {
        throw 'Malformed item';
    }
    
    });
    
    if(position>orderInfo.items.length){
        throw 'Invalid position';
    }
    
    let p=orderInfo.items[position].price;
    let q=orderInfo.items[position].quantity;
    
    orderInfo.items.splice(position,1);
    
    
    orderInfo.total=orderInfo.total-p*q;
    
    return orderInfo;
    
    }
    
    
    
    const app = {
        removeOrderItem
    };
    
    module.exports = app;

Stefi JS V0 5/5

/*
 - funcÈ›ia distance primeÈ™te ca parametrii douÄƒ array-uri
 - fiecare element poate apÄƒrea cel mult o datÄƒ Ã®ntr-un array; orice apariÈ›ii suplimentare sunt ignorate 
 - distanÈ›a dintre cele 2 array-uri este numÄƒrul de elemente diferite dintre ele
 - dacÄƒ parametrii nu sunt array-uri se va arunca o excepÈ›ie ("InvalidType")
*/
/*
 - the distance function receives as parameters two arrays
 - each element can appear in each array at most once; any duplicates are ignored
 - the distance between the 2 arrays is the number of different elements between them
 - if the parameters are not arrays an exception is thrown ("InvalidType")
*/

function distance(first, second){
    if(!(first instanceof Array) || !(second instanceof Array)){
        throw new Error('InvalidType');
    }
    else{
        var duplicates = 0;
        var f = new Set(first);
        var s = new Set(second);
        first = [...f];
        second=[...s];
        for(var i=0;i<first.length;i++){
            for(var j=0; j<second.length;j++){
                if(first[i]===second[j]){
                    duplicates++;
                }
            }
        }
        var dist=(first.length+second.length)-(2*duplicates);

        if(first.length==0 && second.length==0){
            return 0;
        }
        
        return dist;
    }
}

module.exports.distance = distance

Stefi JS V1 5/5
/*
DefiniÈ›i un tip obiectual (Widget)
FuncÈ›ia decorate adaugÄƒ la Widget o metodÄƒ numitÄƒ enhance, care creÈ™te mÄƒrimea unui widget cu "n"
DacÄƒ parametrul trimis nu este un numÄƒr, se aruncÄƒ o excepÈ›ie ("InvalidType")
Metoda funcÈ›ioneazÄƒ È™i asupra Widget-urilor deja declarate
*/

/*
Define a Widget object type is defined
The decorate function adds to Widget a method called enhance which increases the size of a widget with n
If the parameter is not a number an exception is thrown ("InvalidType")
The method also works on already declared Widgets
*/

class Widget {
constructor(name,size){
       this.name=name;
       this.size=size;
    }
    // TODO: completaÈ›i implementarea
    // TODO: finish the implementation

    getDescription(){
        return `a ${this.name} of size ${this.size}`
    }
}

function decorate(){
    Widget.prototype.enhance=function(n){
        if(typeof n !="number")
        {
            throw new Error("InvalidType");
        }
        this.size+=n;
    }
}

module.exports.decorate = decorate
module.exports.Widget = Widget

Stefi JS V2 5/5
/*
Exista un tip obiectual definit (Bird)
SÄƒ se defineascÄƒ tipul Penguin.
Un pinguin este un tip copil pentru Bird È™i are Ã®n plus metoda swim(distance)
Un pinguin nu poate fi creat fÄƒrÄƒ un nume de tip string
Un pinguin nu poate sÄƒ zboare È™i va spune asta dacÄƒ i se cere
DacÄƒ se apeleazÄƒ makeNest, un pinguin va apela metoda pÄƒrintelui sÄƒu
VedeÈ›i testele pentru formatul exact al mesajelor
*/

/*
There is an object type called Bird
Define the Penguin type
A penguin is a child type for Bird and has an additional method called swim(distance)
A penguin cannot be created without a name of type string
A penguin cannot fly and will say that if asked
A penguin can make a nest via its parent's method
See the tests for the accurate format of messages
*/

class Bird {
    constructor(name){
        this.name = name
    }

    fly(distance){
        return `${this.name} flies ${this.distance}`
    }

    makeNest(){
        return `${this.name} makes a nest`
    }

}

class Penguin  extends Bird {
    constructor(name){
        if (!name || typeof name !== 'string'){
            throw new Error('CreationError')
        }
    super(name);
    }
    fly(distance){
        return `${this.name} is a penguin and cannot fly`
    }

   
    swim(distance){
        return `${this.name} swims ${distance}`     
    }
}

// TODO: implementaÈ›i tipul Pinguin
// TODO: implement the Penguin type

module.exports.Bird = Bird
module.exports.Penguin = Penguin

Stefi JS V3 5/5
 /*
 - funcÈ›ia capitalize primeÈ™te ca parametrii un string È™i un array
 - dicÈ›ionarul conÈ›ine o serie de termeni
 - in textul inÈ›ial cuvintele sunt separate de spaÈ›iu
 - fiecare termen din dicÈ›ionar trebuie sÄƒ aparÄƒ capitalizat Ã®n rezultat
 - rezultatul este un string nou, fÄƒrÄƒ modificarea celui iniÈ›ial
 - dacÄƒ textul nu este un string sau dicÈ›ionarul nu este un array de string-uri se va arunca o excepÈ›ie (mesajul TypeError)
*/

/*
 - the capitalize function receives as parameters a string and an array
 - the dictionary (the array) contains a series of words
 - in the initial text the words are separated by space
 - each dictionary term has to appear capitalized in the result
 - the result is a new string without modifying the initial one
 - if the text is not string or the dictionary not an array of strings an exception is thrown (message is TypeError)
*/

function capitalize(text, dictionary){
  if(typeof text!=="string" || !Array.isArray(dictionary))
  {
    throw new Error("TypeError");
  }
  if (dictionary.filter((e) => typeof e !== 'string').length){
        throw new Error('TypeError')        
    }
  let result = text
    let items = result.split(' ')
    for (let i = 0; i < items.length; i++){
        if (dictionary.indexOf(items[i]) !== -1){
            items[i] = items[i][0].toUpperCase() + items[i].slice(1, items[i].length)
        }
    }
    return items.join(' ')
}

module.exports.capitalize = capitalize

Stefi JS V4 5/5

/*
 - funcÈ›ia translate primeÈ™te ca parametrii un string È™i un obiect
 - funcÈ›ia aruncÄƒ excepÈ›ii dacÄƒ tipurile nu sunt respectate (mesajul "InvalidType")
 - obiectul dicÈ›ionar are Ã®n cheie valoarea iniÈ›ialÄƒ È™i Ã®n valoare traducerea ei
 - valorile din dicÈ›ionar sunt string-uri
 - funcÈ›ia Ã®nlocuieÈ™te fiecare cheie din dicÈ›ionar gÄƒsitÄƒ Ã®n textul iniÈ›ial cu valoarea tradusÄƒ
*/

/*
 - the translate function receives as parameters a string and an object
 - the function throws exceptions if the types are not the required ones (message is "InvalidType")
 - the dictionary object has in its keys the inital values and in its values the translation of the key
 - the values in the dictionary are strings
 - the function replaces each dictinary key found in the initial text with the value in the dictionary corresponding to the key
*/

function translate(text, dictionary){
    // TODO: implementaÈ›i funcÈ›ia
    // TODO: implement the function
    if( typeof text!=="string")
    {
        throw new Error("InvalidType");
    }
    if(typeof dictionary!=="object" || !dictionary)
    {
        throw new Error('InvalidType');
    }
    for (let prop in dictionary){
        if (typeof dictionary[prop] !== 'string'){
            throw new Error('TypeError')
        }
    }
    let result = text.split(' ')
    for (let prop in dictionary){
        let position = result.indexOf(prop)
        if (position !== -1){
            result[position] = dictionary[prop]
        }   
    }
    return result.join(' ')
    
    
}

module.exports.translate = translate

Stefi JS V5 5/5

# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie `function textProcessor(input, tokens)` unde:
- `input` este un string ce poate sa contina tokenuri (Example: "Hello ${user}" or "Hello")
- `tokens` este un vector ce contine obiecte cu numele si valoarea tokenurilor.
- Toate tokenurile sunt idetificate sub urmatorul format: `${tokenName}`

function textProcessor(input, tokens){
    if(typeof input=="string")
    {
        if(input.length>=6)
        {
            tokens.forEach((e)=>
            {
                if( typeof e.tokenName=="string" && typeof e.tokenValue=="string" )
                {
                    var t= "${"+ e.tokenName + "}";
                    input= input.replace(t, e.tokenValue);
                }
                else
                {
                    throw new Error("Invalid array format");
                }
            });
            return input;
            
        }
        else
        {
        throw new Error("Input should have at least 6 characters");
        }
    }
    else
    {
        throw new Error("Input should be a string");
    }
  
}

const app = {
    textProcessor: textProcessor
};

module.exports = app;

Stefi JS V6 â€“ pica 
# Subiectul 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie `function applyBonus(employees, bonus)`, completati urmatoarele taskuri:

- Functia trebuie sa returneze un Promise; (0.5 pts)
- Daca `bonus` nu este numar, functia trebuie sa apeleze `reject` cu `Error` si mesajul `Invalid bonus`; (0.5 pts)
- `employees` este un vector ce contine elemente cu urmatorul format: `{name: string, salary: number}` (Example: [{name: "John Doe", salary: 5000}]). Daca este pasat un vector cu elemente invalide, functia trebuie sa apeleze `reject` cu `Error` si mesajul `Invalid array format`; (0.5 pts)
- Functia trebuie sa apeleze `reject` cu `string` cu valoarea `Bonus too small` daca `bonus` este mai mic de 10% din salariul maxim din `employees` array; (0.5 pts)
- Functia trebuie sa apeleze `resolve` cu un vector ce contine salariile marite pentru fiecare angajat; (0.5 pts)

Stefi JS V7 5/5
# Subject 2 (2.5 pts)
# TOPIC: Javascript

# Having the `function applyDiscount(vehicles, discount)`, complete the following tasks:

- Function should return a Promise; (0.5 pts)
- If `discount` is not a number, the function should `reject` an `Error` with the message `Invalid discount`; (0.5 pts)
- `vehicles` is an array that contains objects with the following format: `{make: string, price: number}` (Example: [{make: "Audi A5", price: 15000}]). If an array with invalid objects is passed then the function should `reject` an `Error` with the message `Invalid array format`; (0.5 pts)
- Function should `reject` a `string` with the value `Discount too big` if `discount` is greater than 50% of the min price from `vehicles` array; (0.5 pts)
- Function should `resolve` an array with applied discount to each `vehicle price`; (0.5 pts)

function applyDiscount(vehicles, discount){
      return new Promise((resolve, reject) => {
          if(typeof discount=="number")
          {var minprice=9999999;
             vehicles.forEach((e)=>
             { if(typeof e.make!="string" && typeof e.price!="number")
                {
                var eroare2="Invalid array format";
                reject(new Error(eroare2));
                 }
                 else 
                 {
                     if(e.price<minprice)
                     {
                         minprice=e.price;
                     }
                 }
             
             });
             if(discount> minprice*0.5)
             {
                 reject("Discount too big");
             }
              else {resolve(vehicles.map(e=>{
                    return{make: e.make,price:e.price-discount};
                })); }
        
          }
          else
          {
              var eroare1='Invalid discount';
              reject(new Error(eroare1));
          }
      });
}

const app = {
    applyDiscount: applyDiscount
};

module.exports = app;

Stefi JS V8 5/5
# Subiectul 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie `function addTokens(input, tokens)` unde:
- `input` este un string ce poate sa contina "...". De exemplu: Subsemnatul ..., dominiciliat in ...;
- `tokens` un vector de tokenuri.
- Functia trebuie sa inlocuiasca toate `...` din `input` cu valorile corespunzatoare din `tokens` sub urmatorul format `${tokenName}`, in ordinea in care exista in vector;

# Complete the following tasks:

- `input` trebuie sa fie de tip `string`. Daca alt tip este pasat ca si parametru aruncati `Error` cu mesajul `Input should be a string`; (0.5 pts)
- `input` trebuie sa aiba cel putin 6 caractere ca si lungime. Daca dimensiunea `input-ului` este mai mica de 6, aruncati `Error` cu mesajul `Input should have at least 6 characters`; (0.5 pts)
- `tokens` este un vector de elemente cu urmatorul format: `{tokenName: string}`. Daca urmatorul format nu este respectat, aruncati `Error` cu urmatorul mesaj `Invalid array format`; (0.5 pts)
- Daca `input` nu contine `...` returnati valoarea initiala a `input-ului`; (0.5 pts)
- Daca `input` contine `...`, inlocuiti-le cu valorile specifice si returnati noul `input`; (0.5 pts)

function addTokens(input, tokens){
     if( typeof input!=="string"){
         throw new Error("Invalid input");
     }
    else
    {
        if(input.length <6)
        {
            throw new Error("Input should have at least 6 characters");
        }
        
    else {
        
        tokens.forEach((e)=>
         {
         if( typeof e.tokenName !=="string")
         { 
             throw new Error("Invalid array format");
         }
         else
         {
             
         }
        })
        var inputnou;
        if(input.includes("..."))
        { tokens.forEach((e)=>{
            inputnou=input.replace("...", "${" + e.tokenName +"}");});
            return inputnou;
        }
        else 
        {return input;
            
        }
        
    }
    }
}

const app = {
    addTokens: addTokens
}

module.exports = app;


Stefi JS V9 5/5

# Subiect 2 (2.5 pts)
# TOPIC: Javascript

# Avand urmatoarea functie `function applyBlackFriday(products, discount)` unde:
- `products` un vector de obiecte cu urmatorul format {name: string, price: number};
- `discount` un numar ce reprezinta discount-ul ce va fi aplicat preturilor produselor.
- Functia trebuie sa returneze un vector cu preturile reduse pentru toate produsele.
# Completati urmatoarele cerinte:

- Functia trebuie sa returneze un promise; (0.5 pts)
- `discount` trebuie sa fie un numar, in caz contrar apelati `reject` in promise cu `Error` si mesajul `Invalid discount`; (0.5 pts)
- `discount` trebuie sa fie mai mare ca 0 si mai mic egal cu 10, in caz contrar apelati `reject` in promise cu `Error` si mesajul `Discount not applicable`; (0.5 pts)
- `products` trebuie sa contina produse cu formatul specificat, in caz contrar se va apela `reject` cu `Error` si mesajul `Invalid array format`; (0.5 pts)
Un produs: {name: string, price: number}
- Functia trebuie sa returneze un vector cu preturile reduse pentru toate produsele; (0.5 pts)


function applyBlackFriday(products, discount){
    return new Promise((resolve, reject) => {
        if(typeof discount=="number") {
                 
            products.forEach((e)=>
            {  
                if(typeof e.name!="string" && typeof e.price!="number" )
                {  var eroare1='Invalid array format';
                      reject(new  Error(eroare1));
                      
                }
               
            });
        if(discount<=10 && discount>0)
        {      resolve(products.map(e=>{
                    return{name: e.name,price: e.price- e.price*discount/100};
                }));
        }
        else
        {
            var  eroare2="Discount not applicable";
             reject(new Error(eroare));
        }
     
        } 
        else 
        { var  eroare="Invalid discount";
             reject(new Error(eroare));
        }
    
     })
}

const app = {
    applyBlackFriday: applyBlackFriday
};
module.exports = app;

Stefi JS V10 5/5
# Subiect 2 (2.5 pts)
# TOPIC: Javascript

# DatÄƒ fiind funcÈ›ia `function processString(input)`, care iniÈ›ial tokenizeazÄƒ string-ul `input` Ã®n mai multe `tokens` separate de spaÈ›iu, rezolvaÈ›i urmÄƒtoarele cerinÈ›e:

- DacÄƒ oricare `token` nu este un `number` sau un `Number`, funcÈ›ia ar trebui sÄƒ arunce `Error` 
- DacÄƒ oricare `token` nu este un `number` sau un `Number`, funcÈ›ia ar trebui sÄƒ arunce `Error` cu mesajul `Item is not a number`; (0.5 pts)
- DacÄƒ `input` are lungime 0 funcÈ›ia ar trebui sÄƒ returneze 100; (0.5 pts)
- Token-urile `impare` sunt ignorate; (0.5 pts)
- FuncÈ›ia returneazÄƒ 100 minus suma tuturor `token`-urilor pare; (0.5 pts)

function processString(input){
    if(input.length==0){
        return 100;
    }else{
        let sir=input.split(' ');
        let sum=0;
        for(var i=0;i<sir.length;i++){
            if(!isNaN(sir[i])){
                if(parseInt(sir[i])%2==0){
                    sum+=parseInt(sir[i]);
                }
            }else{
                console.log(typeof parseInt(sir[i]));
                throw new Error("Item is not a number");
            }
        }
        return 100-sum;
    }
    
}
const app = {
    processString: processString
}

module.exports = app

Stefi JS V11 5/5
# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand urmatoarea functie `function getAverageGrade(grades)`, completati urmatoarele taskuri:

- FuncÈ›ia aruncÄƒ o eroare dacÄƒ existÄƒ o notÄƒ negativÄƒ (0.5 pts)
- FuncÈ›ia aruncÄƒ o eroare dacÄƒ nota nu este fie un numÄƒr fie 'A'; (0.5 pts)
- FuncÈ›ia aruncÄƒ o eroare dacÄƒ nota nu este definitÄƒ; (0.5 pts)
- Functia returneazÄƒ nota medie; (0.5 pts)
- FuncÈ›ia returneazÄƒ nota 0 pentru o listÄƒ vidÄƒ de note (0.5 pts)

function getAverageGrade(gradeItems){
     
     var sum=0;
    for(let i =0 ;i < gradeItems.length ;i++)
    {
        if(typeof gradeItems[i].grade !=="number"  ||  gradeItems[i].grade=='A' || typeof gradeItems[i].grade ==="undefined" || gradeItems[i].grade <0 )
        {
            throw new Error("Invalid grade");
        }
        else
        {
             sum+=gradeItems[i].grade;
        }
    }
    if(gradeItems.length===0)
    {
        return 0;
    }
    else{

    return  sum/gradeItems.length;
    }
}

const app = {
    getAverageGrade: getAverageGrade
}

module.exports = app

Stefi JS V11 â€“ 5/5
# Subiect 2 (2.5 pts)
# Tematica: Javascript

# Avand definitÄƒ clasa `Shape` rezolvaÈ›i urmÄƒtoarele taskuri:

- DacÄƒ `Shape` este instanÈ›iatÄƒ direct È™i este apelatÄƒ metoda `area`, se va arunca un obiect `Error`  cu mesajul `not implemented`; (0.5 pts)
- Se va defini clasÄƒ `Square` care extinde `Shape`; Un `Square` poate fi instanÈ›iat pe baza unui obiect cu o proprietate `width`; (0.5 pts)
- Dat fiind un `Square`, se va calcula corect aria acestuia; (0.5 pts)
- Se va defini clasÄƒ `Circle` care extinde `Shape`; Un `Circle` poate fi instanÈ›iat pe baza unui obiect cu o proprietate `radius`; Dat fiind un `Circle`, se va calcula corect aria acestuia; (0.5 pts)
- Se va defini clasÄƒ `Rectangle` care extinde `Shape`; Un `Rectangle` poate fi instanÈ›iat pe baza unui obiect cu o proprietate `width` È™i o proprietate `height`; Dat fiind un `Rectangle`, se va calcula corect aria acestuia; (0.5 pts)

class Shape{
    constructor(dimensions){
        this.dimensions = dimensions

    }
    area(){
        throw Error('not implemented');
    }
    
}

// TODO: Square, Circle, Rectangle
class Square extends Shape{
    constructor(dimensions,width)
    {
        super(dimensions);
        var {width:w}=dimensions;
        this.width=w;
    
    
    }
    area()
    {
        console.log(this.width);
        return this.width*this.width;
    }
    
}
class Circle extends Shape{
    constructor(dimensions,radius)
    {
        super(dimensions);
        var {radius:r}=dimensions;
        this.radius=r;
        
    }

    area()
    {
        return parseInt(Math.PI*this.radius*this.radius);
    }
}
class Rectangle extends Shape{
    constructor(dimensions,width,height)
    {
        super(dimensions);
        var {width:w}=dimensions;
        var {height:h}=dimensions;
        this.width=w;
        this.height=h;
    
    }
    area()
    {
        return this.width*this.height;
    }
}
const app = {
  Shape: Shape,
  Square : Square,
  Circle : Circle,
  Rectangle : Rectangle
}

module.exports = app


REACT
Alice 2 sau Andrei v2
# Subiect 4		5/5
# Tematica: REACT

# Avand urmatoarea aplicatie create folosind `create-react-app`, modificati `Company` si adaugati `CompanyDetails` astfel incat:
- aplicatia se deseneaza corect (0.5 pts);
- `CompanyDetails` are o proprietate numita `item` care contine compania ale carei detalii le afiseaza (0.5 pts);
- `CompanyList` se deseneaza ca o lista de  `Company`, iar fiecare `Company` are un buton cu eticheta `select` (0.5 pts);
- Daca se da click pe butonul select al unui `Company` se deschide afiseaza componenta de detalii (0.5 pts);
- Daca este afisat `CompanyDetails` si se da click pe butonul cancel se afiseaza din nou lista de companii (0.5 pts);

import React, { Component } from 'react'

class Company extends Component {
  render() {
    let {item} = this.props
    return (
      <div>
        Name {item.name} with {item.employees} employees {item.revenue} revenue
        <button id="select" value="select" onClick={() => this.props.onSelect(item)}>Select</button>
      </div>
    )
  }
}

export default Company


import React, { Component } from 'react'

class CompanyDetails extends Component {
    constructor(props) {
        super(props)

        this.state = {
            item: this.props.item
        }

    }

    render() {
        let item  = this.state.item
        return (
            <div>
                Name {item.name} with {item.employees} employees {item.revenue} revenue
                <button id="cancel" value="cancel" onClick={() => this.props.onCancel()}>Cancel</button>
            </div>
        )
    }
}

export default CompanyDetails


import React, { Component } from 'react'
import CompanyStore from '../stores/CompanyStore'
import Company from './Company'
import CompanyDetails from './CompanyDetails'

class CompanyList extends Component {
    constructor() {
        super()
        this.state = {
            companies: [],
            company: {},
            selected: false
        }

    }
    componentDidMount() {
        this.store = new CompanyStore()
        this.setState({
            companies: this.store.getAll()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                companies: this.store.getAll()
            })
        })
    }

    onSelect = item => {
        this.setState({
            selected: true,
        })
        this.setState({
            company: item
        })
    }

    onCancel = () => {
        this.setState({ selected: false });
    }

    render() {
        if (this.state.selected) {
            return(
                <CompanyDetails item={this.state.company} onCancel={this.onCancel} />
            )
        }
        else {
            return (
                <div>
                    {
                        this.state.companies.map((e, i) =>
                            <Company item={e} key={i} onSelect={this.onSelect} />
                        )
                    }
                </div>
            )
        }
    }
}

export default CompanyList


2) Var 3 Alice 5/5 sau examen Robert
# Subiect 4
# Topic: REACT

# Avand urmatoarea aplicatie create folosind modulul `create-react-app` completati urmatoarele cerinte:
- Adaugati componenta `AddDevice` in template-ul componentei `DeviceList`;
- Componenta `AddDevice` trebuie sa contina 2 elemente de tip `input` cu `id`: `name` si `price`;
- Componenta `AddDevice` trebuie sa contina un element de tip `button` cu textul `Submit`, folosit pentru a apela metoda `addItem`;
- Componenta `AddDevice` din interiorul componentei `DeviceList` trebuie sa contina o proprietate numita `onAdd` in obiectul `props`;
- La apasarea butonului `Submit` un nou element va fi afisat si adaugat in starea componentei `DeviceList`;

### INFORMATII UTILE: Obiectele adaugate in vectorul din starea componentei `DeviceList` sunt de forma { name: String, price: Number }.

import React from 'react';

class AddDevice extends React.Component {
    constructor(props){
        super(props)

        this.state = {
            name: '',
            price: 0
        }
    }

    handleChangeName = (e) => {
        this.setState({
            name: e.target.value
        })
    }

    handleChangePrice = (e) => {
        this.setState({
            price: e.target.value
        })
    }

    render() {
        return (
            <div>
                <input type="text" id="name" name="name" value={this.state.name} onChange={(e) => {this.handleChangeName(e)}} ></input>
                <input type="text" id="price" name="price" value={this.state.price} onChange={(e) => {this.handleChangePrice(e)}} ></input>
                <button value="submit" onClick={() => {
                    this.props.onAdd(this.state.name, this.state.price)
                }}>submit</button>
            </div>
        )
    }
}

export default AddDevice;

import React from 'react';
import AddDevice from './AddDevice'

class DeviceList extends React.Component {
    constructor() {
        super();
        this.state = {
            devices: []
        };
    }

    add = (name, price) => {
        let p = parseInt(price);
        let dev = this.state.devices;
        dev.push({
            name: name,
            price: p
        })
        this.setState({ device: dev })
    }

    render() {
        return (
            <div>
                <AddDevice onAdd={this.add} />
            </div>
        )
    }
}

export default DeviceList;

3)React Ana V0 5/5 sau Andrei V0 React
# Subiect 4
# Tematica: REACT

# Avand urmatoarea aplicatie create folosind `create-react-app`, adaugati o componenta `Company` astfel incat:
- aplicatia se deseneaza corect (0.5 pts);
- `CompanyList` este desenata ca un copil al lui `App` (0.5 pts);
- `CompanyList` se deseneaza ca o lista de  `Company` (0.5 pts);
- `Company` are o proprietate numita `item` care contine compania pe care o afiseaza (0.5 pts);
- `Company` poate fi sters prin apasarea unui buton cu eticheta `delete` (0.5 pts);


App.js
import React, { Component } from 'react'
import CompanyList from './CompanyList'

class App extends Component {
  render() {
    return (
      <div>
        A list of companies
        <CompanyList />
      </div>
    )
  }
}

export default App


company.js
import React, { Component } from 'react'

class Company extends Component{

    render(){
        let {item} = this.props

        return(
            <div>{item.name}
            <input type="button" value="delete" onClick={() => this.props.onDelete(item.id)} />
            </div>

        )
    }
}


export default Company


CompanyList.js
import React, { Component } from 'react'
import CompanyStore from '../stores/CompanyStore'
import Company from './Company'

class CompanyList extends Component {
    constructor(){
        super()
        this.state = {
            companies : []
        }
        this.deleteCompany = (id) => {
            this.store.deleteOne(id)
        }
    }
    componentDidMount(){
        this.store = new CompanyStore()
        this.setState({
            companies : this.store.getAll()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                companies : this.store.getAll()
            })          
        })
    }
  render() {
    return (
      <div>
            {
            this.state.companies.map((e, i) => 
              <Company item={e} key={i} onDelete={this.deleteCompany}/>
            )
        }
      </div>
    )
  }
}

export default CompanyList


4)React Ana V1 5/5 sau Andrei V1
# Subiect 4
# Tematica: REACT

# Avand urmatoarea aplicatie create folosind `create-react-app`, modificati `Company` astfel incat:
- aplicatia se deseneaza corect (0.5 pts);
- `CompanyList` se deseneaza ca o lista de  `Company`, iar fiecare `Company` are un buton cu eticheta `edit` (0.5 pts);
- Daca se da click pe butonul edit al unui `Company` aceasta trece in mod de editare (0.5 pts);
- Daca in mod edit se da click pe butonul cancel al unui `Company` aceasta trece in mod view (0.5 pts);
- Se poate salva o companie, iar schimbarea se reflecta in lista de companii (0.5 pts);

App.js
import React, { Component } from 'react'
import CompanyList from './CompanyList'

class App extends Component {
  render() {
    return (
      <div>
        A list of companies
        <CompanyList />
      </div>
    )
  }
}

export default App

Company.js
import React, { Component } from 'react'

class Company extends Component {
  constructor(props){
    super(props)
    let {item} = this.props
    this.state = {
      name : item.name,
      employees : item.employees,
      revenue : item.revenue,
      
      isEditing: false
    }
    this.handleChange = (evt) => {
      this.setState({
        [evt.target.name] : evt.target.value
      })
    }
  }
  render() {
    let {item} = this.props
    if (this.state.isEditing){
      return (
        <div>
          <input type="text" id="name" name="name" onChange={this.handleChange} value={this.state.name} />
           <input type="text" id="employees" name="employees" onChange={this.handleChange} value={this.state.employees} />
            <input type="text" id="revenue" name="revenue" onChange={this.handleChange} value={this.state.revenue} />
            <input type="button" value="save" onClick={() => {
              this.props.onSave(item.id, {
                name : this.state.name,
                employees : this.state.employees,
                revenue : this.state.revenue
              })
              this.setState({isEditing : false})
              }
            } />
          <input type="button" value="cancel" onClick={() => this.setState({isEditing : false})} />           
        </div>
      )
    }
    else{
      return (
        <div>
          Name {item.name} with {item.employees} employees {item.revenue} revenue
          <input type="button" value="edit" onClick={() => this.setState({isEditing : true})} />    
        </div>
      )
    }
  }
}

export default Company


CompanyList.js
import React, { Component } from 'react'
import CompanyStore from '../stores/CompanyStore'
import Company from './Company'

class CompanyList extends Component {
    constructor(){
        super()
        this.state = {
            companies : []
        }
        this.saveCompany = (id, company) => {
            this.store.saveOne(id, company)
        }
    }
    componentDidMount(){
        this.store = new CompanyStore()
        this.setState({
            companies : this.store.getAll()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                companies : this.store.getAll()
            })          
        })
    }
  render() {
    return (
      <div>
            {
            this.state.companies.map((e, i) => 
                <Company item={e} key={i} onSave={this.saveCompany} />
            )
        }
      </div>
    )
  }
}

export default CompanyList


5) React Ana V4 5/5
# Subiect 4
# Tematica: REACT

# Avand urmatoarea aplicatie pentru vanzare automata de produse  realizati modificari astfel incat:
- aplicatia se deseneaza corect (0.5 pts)
- incarcati lista de produse din ProductStore la desenarea componentei `VendingMachine` (0.5 pts)
- adaugati componenta `Product` afisati numele, pretul si un buton cu eticheta buy care apeleaza metoda onBuy (0.5 pts)
- implementati metoda addTokens care incrementeaza numarul de token cu 1 la fiecare apasare de buton (0.5 pts)
- implementati metoda buyProduct care scade numarul de tokeni cu pretul produsului cumparat; daca nu sunt suficienti tokeni nu se realizeaza vanzare (0.5 pts)

App.js
import React, { Component } from 'react'
import VendingMachine from './VendingMachine'

class App extends Component {
  render() {
    return (
      <div>
        Vending Machine
        <VendingMachine />
      </div>
    )
  }
}

export default App


Product.js
import React, { Component } from 'react'

class Product extends Component {
    render(){
        return(
            <div>
                <h1>{this.props.name}</h1>
                <h1>{this.props.price}</h1>
                <input type="button" value="buy" onClick={() => this.props.onBuy(this.props.price) } ></input>
      
           
            </div>
            
        )
    }
}

export default Product

VendingMachine.js
import React, { Component } from 'react'
import Product from './Product'
import ProductStore from '../stores/ProductStore'

class VendingMachine extends Component {
    constructor() {
        super()
        this.state = {
            products: [],
            tokens: 0
        }

        this.addToken = () => {
           
            this.setState({tokens: this.state.tokens + 1})
          
        }

        this.buyProduct = (price) => {
            if(this.state.tokens >= price  ){
                this.setState({tokens:this.state.tokens -price})
             }else{
                alert("Nu sunt suficienti tokens")
             }
        }
    }
    componentDidMount(){
        let productStore = new ProductStore()

        this.setState({products: productStore.getAll()})

}

    render() {
        return (
            <div>
                {this.state.products.map((el, index) => <Product key={index} name={el.name} price={el.price} onBuy={this.buyProduct}  />)}
                <div>Tokens: {this.state.tokens}</div>
                <input type="button" value="add token"  onClick={this.addToken}/>
            </div>
        )
    }
}

export default VendingMachine

Stefi React V0 5/5
import React, { Component } from 'react'
import RobotStore from '../stores/RobotStore'
import Robot from './Robot'

// TODO : adÄƒugaÈ›i o componentÄƒ Robot 
// afiÈ™aÈ›i o componentÄƒ Robot pentru fiecare robot din stare 
// o componentÄƒ robot ar trebui sÄƒ afiÈ™eze un robot È™i sÄƒ permitÄƒ È™tergerea lui

// TODO : add a Robot component 
// show a Robot component for each robot in the state
// a robot component should show a robot and allow deletion of a robot

class RobotList extends Component {
    constructor(){
        super()
        this.state = {
            robots : []
        }
        this.deleteRobot = (id) => {
            this.store.deleteRobot(id)
        }
    }
    componentDidMount(){
        this.store = new RobotStore()
        this.setState({
            robots : this.store.getRobots()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                robots : this.store.getRobots()
            })          
        })
    }
  render() {
    return (
      <div>
        {
             this.state.robots.map((e, i) => <Robot key={i} item={e} onDelete={this.deleteRobot}/>)
        }
      </div>
    )
  }
}

export default RobotList


import React, { Component } from 'react'

class Robot extends Component {
  render() {
    let {item} = this.props
    return (
      <div>
      Hello, my name is {item.name}. I am a {item.type} and weigh {item.mass}
      <input type="button" value="delete" onClick={() => this.props.onDelete(item.id)} />
      </div>
    )
  }
}

export default Robot


Stefi React V1 5/5
import React, { Component } from 'react'
import RobotStore from '../stores/RobotStore'
import Robot from './Robot'
import RobotForm from './RobotForm'

// TODO : adÄƒugaÈ›i o componentÄƒ RobotForm 
// RobotForm ar sÄƒ permitÄƒ adÄƒugarea unui robot

// TODO : add a RobotForm component 
// RobotForm should be able to add a robot

class RobotList extends Component {
    constructor(){
        super()
        this.state = {
            robots : []
        }
        this.store = new RobotStore();

        this.add = (robot) => {
            this.store.addRobot(robot)
        }
    }
     
    componentDidMount(){
        this.store = new RobotStore()
        this.setState({
            robots : this.store.getRobots()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                robots : this.store.getRobots()
            })          
        })
    }
    render() {
        return (
            <div>
                 
                {
                    this.state.robots.map((e, i) => 
                        <Robot item={e} key={i} />
                    )
                }
                  <RobotForm onAdd={this.add} />
            </div>
        )
    }
}

export default RobotList


import React from 'react';
import {Component} from 'react';

class RobotForm extends Component {
    constructor(props){
        super(props)
        this.state = {
            id : '',
            type : '',
            name : '',
            mass : ''
        }
        this.handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
    }
     render(){
        return <div>
            <input id="id" name="id" onChange={this.handleChange} />
            <input id="type" name="type" onChange={this.handleChange} />
             <input id="name" name="name" onChange={this.handleChange} />
              <input id="mass" name="mass" onChange={this.handleChange} />
             <input type="button"  value="add" onClick={() => this.props.onAdd({
              id : this.state.id,
              type : this.state.type,
              name : this.state.name,
               mass : this.state.mass,
            })} />
        </div>
    }
}



export default RobotForm;

Stefi React V2 5/5

import React, { Component } from 'react'

// TODO : adÄƒugaÈ›i posibilitatea de a edita un robot 
// editarea se face prin intermediul unui robot cu 2 stÄƒri, una de vizualizare È™i una de editare

// TODO : add the posibility to edit a robot 
// editing is done via 2 states a view state and an edit state

class Robot extends Component {
    constructor(props){
        super(props);
         this.state = {
            isEditing : false,
            name : this.props.item.name,
            type : this.props.item.type,
            mass : this.props.item.mass
        }
          this.handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
      
    }
    render() {
        let {item} = this.props
                if (this.state.isEditing){

        return (
            <div>
                   <input type="text"  id="name" name="name" onChange={this.handleChange} value={this.state.name} />
                   <input type="text"  id="type" name="type" onChange={this.handleChange}  value={this.state.type}/>
                   <input type="text"  id="mass" name="mass" onChange={this.handleChange}  value={this.state.mass}/>
                 <input type="button" value="save" onClick={() => {
                            this.props.onSave(item.id, {
                                name : this.state.name,
                                type : this.state.type,
                                mass : this.state.mass
                            })
                            this.setState({isEditing : false})
                            }
                        } />
                <input type="button" value="cancel" onClick={() => this.setState({
                    isEditing : false
                })} />
            </div>
        )
    }
    else{
          return (<div>
                                Hello, my name is {item.name}. I am a {item.type} and weigh {item.mass}
                    <input type="button" value="edit" onClick={() => this.setState({isEditing : true})} />

                </div>)
    }
    
}
}

export default Robot;


import React, { Component } from 'react'
import RobotStore from '../stores/RobotStore'
import Robot from './Robot'

class RobotList extends Component {
    constructor(){
        super()
        this.state = {
            robots : []
        }
        this.saveRobot = (id, robot) => {
            this.store.saveRobot(id, robot)
        }
    }
    componentDidMount(){
        this.store = new RobotStore()
        this.setState({
            robots : this.store.getRobots()
        })
        this.store.emitter.addListener('UPDATE', () => {
            this.setState({
                robots : this.store.getRobots()
            })          
        })
    }
  render() {
    // a robot component should show a robot and allow editing a robot
    return (
      <div>
         
        {
            this.state.robots.map((e, i) => 
                <Robot item={e} key={i} onSave={this.saveRobot} />
            )
        }
      </div>
    )
  }
}

export default RobotList


Stefi React V3 ---nu stiu cerinta? Dar ruleaza tot

Stefi React V5 â€“ 5/5
# Subiect 4
# Tematica: REACT

# Avand urmatoarea apliatie create folosind `create-react-app`, completati urmatoarele taskuri:
- Componenta `AddCar` trebuie adaugata in interiorul componentei `CarList`;
- Componenta `AddCar` trebuie sa contina 3 elemente de tip input cu `id-ul` si `name-ul`: `make`, `model`, `price`;
- Componenta `AddCar` trebuie sa contina un element input de tip buton `button` cu valoarea `add car`, folosit pentru a apela metoda `addCar`;
- Componenta `AddCar` din interiorul componentei `CarList` trebuie sa contina in `props` metoda `onAdd`;
- La apasarea butonului `add car` un nou element trebuie afisat in componenta `CarList`;

import React from 'react';

export class AddCar extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            make: '',
            model: '',
            price: ''
        }
        
    }

    addCar = () => {
        let car = {
            make: this.state.make,
            model: this.state.model,
            price: this.state.price
        };
        this.props.onAdd(car);
    
    }
    handleChangeModel=(event)=>{
        this.setState({
            model:event.target.value
        });
    }
     handleChangePrice=(event)=>{
        this.setState({
            price:event.target.value
        });
    }
     handleChangeMake=(event)=>{
        this.setState({
            make:event.target.value
        });
    }
    render(){
        return (
            <div>
                <input id="make"  name="make" onChange={this.handleChangeMake} />
                 <input id="model"  name="model" onChange={this.handleChangeModel} />
                 <input id="price"  name="price" onChange={this.handleChangePrice}/>
                 <input type="button" value="add car" onClick={this.addCar}/>
            </div>
        )
    }
}
export default AddCar;

import React from 'react';
import AddCar from './AddCar.js'
 

export class CarList extends React.Component {
    constructor(){
        super();
        this.state = {
            cars: []
        };
            
    
      this.addCar = (car) => {
            var cars1=this.state.cars;
            cars1.push(car);
            this.setState=({
                cars:cars1
            })
        }
    }

    render(){
        return (
            <div>
                 
                {
                    <AddCar onAdd={this.addCar}/>
                
                    
                }
                
            </div>
        )
    }
}

Stefi React V6 â€“ 5/6
# Subiect 4
# Tematica: REACT

# Avand urmatoarea apliatie create folosind `create-react-app`, completati urmatoarele taskuri:
- Componenta `AddProduct` trebuie adaugata in interiorul componentei `ProductList`;
- Componenta `AddProduct` trebuie sa contina 3 elemente de tip input cu `id-ul` si `name-ul`: `name`, `category`, `price`;
- Componenta `AddProduct` trebuie sa contina un element input de tip buton `button` cu valoarea `add product`, folosit pentru a apela metoda `addProduct`;
- Componenta `AddProduct` din interiorul componentei `ProductList` trebuie sa contina in `props` metoda `onAdd`;
- La apasarea butonului `add product` un nou element trebuie afisat in componenta `ProductList`;

import React from 'react';
import AddProduct from './AddProduct';

export class ProductList extends React.Component {
    constructor(){
        super();
        this.state = {
            products: []
        };
         this.add = (product) => {
            this.store.addProduct(product);
        }
        
    }

    render(){
        return(
            <div>
             <AddProduct onAdd={this.add} />
            </div>
        )
    }
}

import React from 'react';

export class AddProduct extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            name: '',
            category: '',
            price: ''
        };
       this.handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
    }

    addProduct = () => {
        let product = {
            name: this.state.name,
            category: this.state.category,
            price: this.state.price
        };
        this.props.onAdd(product);
    }
    

     render(){
        return <div>
            <input id="name" name="name" onChange={this.handleChange} />
            <input id="category" name="category" onChange={this.handleChange} />
             <input id="price" name="price" onChange={this.handleChange} />
           
             <input type="button"  value="add product" onClick={() => this.props.onAdd({
              name : this.state.name,
              category : this.state.category,
              price : this.state.price,
             
            })} />
        </div>
    }
}
export default AddProduct;

Stefi React V7 6/6
# Subiect 4
# Tematica: REACT

# Avand urmatoarea apliatie create folosind `create-react-app`, completati urmatoarele taskuri:
- Componenta `AddStudent` trebuie adaugata in interiorul componentei `StudentList`;
- Componenta `AddStudent` trebuie sa contina 3 elemente de tip input cu `id-ul` si `name-ul`: `name`, `surname`, `age`;
- Componenta `AddStudent` trebuie sa contina un element input de tip buton `button` cu valoarea `add student`, folosit pentru a apela metoda `addStudent`;
- Componenta `AddStudent` din interiorul componentei `StudentList` trebuie sa contina in `props` metoda `onAdd`;
- La apasarea butonului `add student` un nou element trebuie afisat in componenta `StudentList`;

import React from 'react';

export class AddStudent extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            name: '',
            surname: '',
            age: ''
        };
       
    }
  handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
    addStudent = () => {
        let student = {
            name: this.state.name,
            surname: this.state.surname,
            age: this.state.age
        };
        this.props.onAdd(student);
    }
    

    render(){
        return (
            <div>
                <input id="name" name="name" onChange={this.handleChange} />
            <input id="surname" name="surname" onChange={this.handleChange} />
             
              <input id="age" name="age" onChange={this.handleChange} />
             <input type="button"  value="add student" onClick={this.addStudent} /> 
            </div>
        )
    }
}
export default AddStudent;

import React from 'react';
import AddStudent from './AddStudent';

export class StudentList extends React.Component {
    constructor(){
        super();
        this.state = {
            students: []
        };
        
      this.addStudent = (student) => {
            var students1=this.state.students;
            students1.push(student);
            this.setState=({
                students:students1
            })
        }
    }

    render(){
        return (
            <div>
            <AddStudent onAdd={this.addStudent}/>

            </div>
        )
    }
}

Stefi React V8 1/6
# Subject 4
# Topic: REACT

# Having the following application created with `create-react-app` complete the following tasks:
- `AddEmployee` component should be rendered inside `EmployeeList` component;
- `AddEmployee` component should contain 3 inputs with `id` and `name`: `name`, `surname`, `experience`;
- `AddEmployee` component should contain an input of type `button` with the value `add employee`, used to trigger `addEmployee` method;
- `AddEmployee` component inside `EmployeeList` should contain a `props` called `onAdd`;
- When pressing `add employee` a new item should be displayed in `EmployeeList` component;

import React from 'react';

export class AddEmployee extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            name: '',
            surname: '',
            experience: ''
        };
    }

    addEmployee = () => {
        let employee = {
            name: this.state.name,
            surname: this.state.surname,
            experience: this.state.experience
        };
        this.props.onAdd(employee);
    }

    render(){
        return (
            <div>
                
            </div>
        )
    }
}

import React from 'react';

export class EmployeeList extends React.Component {
    constructor(){
        super();
        this.state = {
            employees: []
        };
    }

    render(){
        return(
            <div>
                
            </div>
        )
    }
}


Stefi React V9 5/6
# Subiect 4
# Tematica: REACT

# Avand urmatoarea apliatie create folosind `create-react-app`, completati urmatoarele taskuri:
- Componenta `AddCoupon` trebuie adaugata in interiorul componentei `CouponList`;
- Componenta `AddCoupon` trebuie sa contina 3 elemente de tip input cu `id-ul` si `name-ul`: `category`, `discount`, `availability`;
- Componenta `AddCoupon` trebuie sa contina un element input de tip buton `button` cu valoarea `add coupon`, folosit pentru a apela metoda `addCoupon`;
- Componenta `AddCoupon` din interiorul componentei `CouponList` trebuie sa contina in `props` metoda `onAdd`;
- La apasarea butonului `add coupon` un nou element trebuie afisat in componenta `CouponList`;

import React from 'react';

export class AddCoupon extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            category: '',
            discount: '',
            availability: ''
        };
        
        
    }
  handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
    addCoupon = () => {
        let coupon = {
            category: this.state.category,
            discount: this.state.discount,
            availability: this.state.availability
        };
        this.props.onAdd(coupon);
    }

    render(){
        return(
            <div>
               <input id="category" name="category" onChange={this.handleChange} />
            <input id="discount" name="discount" onChange={this.handleChange} />
             <input id="availability" name="availability" onChange={this.handleChange} />
             
             <input type="button"  value="add coupon" onClick={this.addCoupon} />
       
            </div>
        )
    }
}
export default AddCoupon;

import React from 'react';
import AddCoupon from './AddCoupon';

export class CouponList extends React.Component {
    constructor(){
        super();
        this.state = {
            coupons: []
        };
           this.addCoupon = (coupon) => {
            var coupons1=this.state.coupons;
            coupons1.push(coupon);
            this.setState=({
                coupons:coupons1
            })
        }
    }

    render(){
        return(
            <div>
                <AddCoupon onAdd={this.addCoupon}/>
            </div>
        )
    }
}

Stefi React V10 5/5
# Subject 4
# Topic: REACT
# Having the following application created with `create-react-app` complete the following tasks:
- `AddTask` component should be rendered inside `TaskList` component;
- `AddTask` component should contain 3 inputs with the following properties `id` and `name` having the following values: `task-name`, `task-priority`, `task-duration`;
- `AddTask` component should contain an input of type `button` with the `value` property `add task`, used to trigger `addTask` method;
- `AddTask` component inside `TaskList` should contain a `props` called `taskAdded`;
- When pressing `add task` button a new item should be displayed in `TaskList` component; 

import React from 'react';

export default  class AddTask extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            taskName: '',
            taskPriority: 'low',
            taskDuration: 0
        };
    }
  handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
  
    render(){
        return (
        <div>
                <input id="task-name"  name="task-name" onChange={this.handleChange} />
                 <input id="task-priority"  name="task-priority" onChange={this.handleChange} />
                 <input id="task-duration"  name="task-duration" onChange={this.handleChange}/>
                 <input type="button" value="add task" onClick={this.addTask}/>
        </div>
        );
    }

  addTask = () => {
        let task = {...this.state};
        this.props.taskAdded(task);
    }
}


import React from 'react';
import AddTask from './AddTask';

export default class TaskList extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            data: []
          };
          this.addTask = (task) => {
            var task1=this.state.data;
            task1.push(task);
            this.setState=({
                task:task1
            })
        }
    }

    render() {
        return (
            <div>
             <AddTask taskAdded={this.addTask} />
            </div>
        );
    }
}

Stefi React V11 5/5
# Subject 4
# Topic: REACT
# Having the following application created with `create-react-app` complete the following tasks:
- `AddBook` component should be rendered inside `BookList` component;
- `AddBook` component should contain 3 inputs with the following properties `id` and `name` having the following values: `book-title`, `book-type`, `book-price`;
- `AddBook` component should contain an input of type `button` with the `value` property `add book`, used to trigger `handleAdd` method;
- `AddBook` component inside `BookList` should contain a `props` called `itemAdded `;
- When pressing `add book` button a new item should be displayed in `BookList` component; 

import React from 'react';

export default class AddBook extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            bookTitle: '',
            bookType: '',
            bookPrice: 0
        };
    }
handleChange = (evt) => {
            this.setState({
                [evt.target.name] : evt.target.value
            })
        }
  
    render(){
        return (
        <div>
                <input id="book-title"  name="book-title" onChange={this.handleChange} />
                 <input id="book-type"  name="book-type" onChange={this.handleChange} />
                 <input id="book-price"  name="book-price" onChange={this.handleChange}/>
                 <input type="button" value="add book" onClick={this.handleAdd}/>
        </div>
        );
    }

    handleAdd = () => {
        let item = {...this.state};
        this.props.itemAdded(item);
    }
}

import React from 'react';
import AddBook from './AddBook'
export default class BookList extends React.Component {
    constructor(props){
        super(props);
        this.state = {
            data: []
          };
           this.addBook = (book) => {
            var book1=this.state.data;
            book1.push(book);
            this.setState=({
                book:book1
            })
        }
    }

    render() {
        return (
            <div>
             <AddBook itemAdded={this.addBook} />
            </div>
        );
    }
}

Stefi React V12 
# Subject 4
# Topic: REACT
# Having the following application created with `create-react-app` complete the following tasks:
- `AddTransaction` component should be rendered inside `TransactionList` component;
- `AddTransaction` component should contain 3 inputs with the following properties `id` and `name` having the following values: `transaction-number`, `transaction-type`, `transaction-amount`;
- `AddTransaction` component should contain an input of type `button` with the `value` property `add transaction`,used to trigger `addTransaction` method;
- `AddTransaction` component inside `TransactionList` should contain a `props` called `itemAdded`;
- When pressing `add transaction` button a new item should be displayed in `TransactionList` component; 


REST
Ana Rest v2 0/5 sau V2 Alice sau Andrei V2
#Subiect 3 (2.5 pts)		0/5
#TOPIC: REST	

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metoda `GET` la adresa `/ships`:
- se pot utiliza parametrii de query `page` si `pageSize`

- Daca nu s-a specificat nici pagina si marimea paginii, se vor returna toate navele (0.5 pts)
- Daca s-a specificat pagina, dar nu page size se va presupune ca marimea paginii este 5 si se va returna a n-a pagina de 5 nave (0.5 pts)
- Daca s-au specificat atat pagina cat si marimea unei pagini, se va returna pagina specificata de marimea specificata (0.5 pts)
- Daca s-a specificat o pagina malformata sau o marime de pagina malformata se vor returna toate navele; (0.5 pts)
- Daca pagina specificata este dincolo de ultima nava, se va returna un array vid. (0.5 pts)

Ana Rest V3
#Subiect 3 (2.5 pts)		0/5
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metodele `POST` si `DELETE` pe pathurile `/device` si `/device/:id`:
- `POST /device` returneaza status code 400 si raspuns `{message: "bad request"}` daca `body-ul` este gol. (0.5 pts)
- `POST /device` returneaza status code 400 si raspuns `{message: "bad request"}` daca `pretul < 0`. (0.5 pts)
- `POST /device` returneaza status code 400 si raspuns `{message: "bad request"}` daca `numele are mai putin de 4 caractere`. (0.5 pts)
- `POST /device` returneaza status code 201 si raspuns `{message: "device created"}` daca `body-ul este valid`. (0.5 pts)
- `DELETE /device/:id` returneaza status code 202 si raspuns `{message: "device deleted"}` daca `id-ul` trimis ca request parameter este gasit in baza de date. (0.5 pts)


Examen Robert 0/5 sau Ana v1 sau Andrei V1
#Subiect 3 (2.5 pts)
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metodele `PUT` si `DELETE` la adresa `/ships/id`:

- Daca se incerca modificarea unei nave inexistente raspunsul trebuie sa fie `{"message": "not found"}`. Codul de raspuns va fi: `404`; (0.5 pts)
- Daca se incearca modificarea unei nave existente raspunsul trebuie sa fie `{"message": "accepted"}`. Codul de raspuns va fi: `202`; (0.5 pts)
- O cerere get ulterioara la adresa navei editate trebuie sa reflecte modificarile. Codul de raspuns va fi: `200`; (0.5 pts)
- Daca se incearca stergerea unei nave existente raspunsul trebuie sa fie `{"message": "accepted"}`. Codul de raspuns va fi: `202`; (0.5 pts)
- O cerere get ulterioara la adresa navei sterse trebuie sa returneze `{"message": "not found"}`. Codul de raspuns va fi: `404`; (0.5 pts)

Ana Rest V0 â€“ 3/5
#Subiect 3 (2.5 pts)
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metoda `POST` la adresa `/ships`:

- DacÄƒ s-a trimis un request cu un corp gol sau nedefinit, se va returna un json cu urmÄƒtorul format: `{"message": "body is missing"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- DacÄƒ din corpul request-ului lipsesc proprietÄƒÈ›i se va returna un json cu urmÄƒtorul format: `{"message": "malformed request"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- Deplasamentul trebuie sa fie un numar mai mare ca 1000; Ã®n caz contrar se va returna un json cu urmÄƒtorul format: `{"message": "displacement should be over 1000"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- DacÄƒ nava trimisa prin corpul request-ului este valida, va fi adÄƒugata È™i se va returna un rÄƒspuns cu  codul `201`. Corpul rÄƒspunsului va fi `{"message": "created"}`;(0.5 pts)
- DacÄƒ se face un request `GET /ships` corpul rÄƒspunsului trebuie sÄƒ conÈ›inÄƒ 11 `ships`, inclusiv cea adÄƒugata anterior; (0.5 pts)

const express = require('express')
const bodyParser = require('body-parser')
const Sequelize = require('sequelize')

const mysql = require('mysql2/promise')

const DB_USERNAME = 'root'
const DB_PASSWORD = 'robert123'

let conn

mysql.createConnection({
    user : DB_USERNAME,
    password : DB_PASSWORD
})
.then((connection) => {
    conn = connection
    return connection.query('CREATE DATABASE IF NOT EXISTS tw_exam')
})
.then(() => {
    return conn.end()
})
.catch((err) => {
    console.warn(err.stack)
})

const sequelize = new Sequelize('tw_exam', DB_USERNAME, DB_PASSWORD,{
    dialect : 'mysql',
    logging: false
})

let Ship = sequelize.define('student', {
    name : Sequelize.STRING,
    portOfSail : Sequelize.STRING,
    displacement : Sequelize.INTEGER
},{
    timestamps : false
})

const app = express()
app.use(bodyParser.json())

app.get('/create', async (req, res) => {
    try{
        await sequelize.sync({force : true})
        for (let i = 0; i < 10; i++){
            let ship = new Ship({
                name : `name${i}`,
                portOfSail : `port ${i}`,
                displacement : 3000 + 10 * i
            })
            await ship.save()
        }
        res.status(201).json({message : 'created'})
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})
    }
})

app.get('/ships', async (req, res) => {
    try{
        let ships = await Ship.findAll()
        res.status(200).json(ships)
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})        
    }
})

app.post('/ships', async (req, res) => {
    try{
        //1.
        if(req.body.constructor === Object && Object.keys(req.body).length === 0){
            res.status(400).send({"message": "body is missing"})
        }

        //2.
        if( !(req.body.hasOwnProperty('name'))|| !(req.body.hasOwnProperty('portOfSail')) || !(req.body.hasOwnProperty('displacement')) ) {
          res.status(400).send({"message":"malformed request"})
        }

        //3.
        const deplasament = Object.getOwnPropertyDescriptor(req.body, "displacement")
        if(deplasament.value < 1000){
            res.status(400).send({"message": "displacement should be over 1000"})
        }
        else{
        //4.
        await Ship.create(req.body)
        res.status(201).send({'message':'created'})

        }
    }
    catch(err){

    }
})

module.exports = app

Ana Rest V4 0/5
#Subiect 3 (2.5 pts)
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metoda `GET` la adresa `/homeworks` si metoda `GET` la adresa `/homeworks/id`:

- Daca metoda GET /homeworks a fost apelata fara parametri va returna toate temele din baza de date
- Daca metoda GET /homeworks a fost apelata cu parametrul pass = true va returna toate temele care au obtinut o nota mai mare sau egala ca 5
- Daca metoda GET /homeworks/id a fost apelata cu id inexistent returneaza status code `404`
- Daca metoda GET /homeworks/id a fost apelata cu un id valid returneaza un obiect json
- Daca clientul HTTP accepta doar text metoda GET /homeworks/id returneaza doar continutul temei


Stefi Rest Var 5
#Subiect 3
#Tematica: REST

# Avand urmatoa aplicatie dezvoltata in NodeJS, sa se completeze metoda de tip `POST` de pe calea `/products` :

- Daca nu exista body pentru cererea http, trebuie sa returnati un JSON cu urmatorul format: `{message: "Body is missing"}`. Codul de raspuns trebuie sa fie: `500`;
- Daca body-ul nu respecta formatul unui produs, trebuie sa returnati un JSON cu urmatorul format: `{message: "Invlid body format"}`. Codul de raspuns trebuie sa fie: `500`;
- Pretul unui produs trebuie sa fie mai mare ca 0.In caz contrar trebuie sa returnati un JSON cu urmatorul format: `{message: "Price should be a positive number"}`. Codul de raspuns trebuie sa fie: `500`; 
- Daca produsul exista deja in vector, trebuie sa returnati un JSON cu urmatorul format: `{message: "Product already exists"}`.Codul de raspuns trebuie: `500`. Unicitatea se face in functie de nume;
- Daca body-ul are formatul corespunzator, produsul trebuie adaugat in vector si sa returnati un JSON cu urmatorul format: `{message: "Created"}`. Codul de raspuns trebuie sa fie: `201`;

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');

const app = express();

app.use(bodyParser.json());
app.use(cors());

app.locals.products = [
    {
        name: "Iphone XS",
        category: "Smartphone",
        price: 5000
    },
    {
        name: "Samsung Galaxy S10",
        category: "Smartphone",
        price: 3000
    },
    {
        name: "Huawei Mate 20 Pro",
        category: "Smartphone",
        price: 3500
    }
];

app.get('/products', (req, res) => {
    res.status(200).json(app.locals.products);
});

app.post('/products', (req, res, next) => {
    if(JSON.stringify(req.body)=='{}')
    {
        res.status(500).json({message:"Body is missing"});
    }
    else{
        if(req.body.name && req.body.category && req.body.price)
        { if(req.body.price >0)
        { var ok=true;
            app.locals.products.forEach((e)=>
            {
                if(e.name== req.body.name)
                { ok=false;
                res.status(500).json({message: "Product already exists"});
                }
              
            });
           if(ok==true) app.locals.products.push({name: req.body.name, category: req.body.category, price: req.body.price});
            res.status(201).json({message: "Created"});
        }
        else
        { 
            res.status(500).json({message: "Price should be a positive number"});
        }
            
        }
        else
        {
            res.status(500).json({message: "Invalid body format"});
        }
    
    }
})

module.exports = app;

Stefi Rest Var 8 5/5
#Subiect 3
#Tematica: REST

# Avand urmatoa aplicatie dezvoltata in NodeJS, sa se completeze metoda de tip `POST` de pe calea `/students` :

- Daca nu exista body pentru cererea http, trebuie sa returnati un JSON cu urmatorul format: `{message: "Body is missing"}`. Codul de raspuns trebuie sa fie: `500`;
- Daca body-ul nu respecta formatul unui student, trebuie sa returnati un JSON cu urmatorul format: `{message: "Invlid body format"}`. Codul de raspuns trebuie sa fie: `500`;
- Varsta unui student trebuie sa fie mai mare ca 0.In caz contrar trebuie sa returnati un JSON cu urmatorul format: `{message: "Age should be a positive number"}`. Codul de raspuns trebuie sa fie: `500`; 
- Daca studentul exista deja in vector, trebuie sa returnati un JSON cu urmatorul format: `{message: "Student already exists"}`.Codul de raspuns trebuie: `500`. Unicitatea se face in functie de nume;
- Daca body-ul are formatul corespunzator, studentul trebuie adaugat in vector si sa returnati un JSON cu urmatorul format: `{message: "Created"}`. Codul de raspuns trebuie sa fie: `201`;

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');

const app = express();

app.use(bodyParser.json());
app.use(cors());

app.locals.students = [
    {
        name: "Gigel",
        surname: "Popel",
        age: 23
    },
    {
        name: "Gigescu",
        surname: "Ionel",
        age: 25
    }
];

app.get('/students', (req, res) => {
    res.status(200).json(app.locals.students);
});

app.post('/students', (req, res, next) => {
   if(JSON.stringify(req.body)=="{}")
    {
        res.status(500).json({message:'Body is missing'});
    }
    else
    {
        if(req.body.name && req.body.surname && req.body.age)
        {
            if(req.body.age<0)
            {
                res.status(500).json({message: 'Age should be a positive number'});
            }
            else
            {
                var ok=true;
                app.locals.students.forEach(s=>{
                    if(s.name==req.body.name){
                        
                        res.status(500).json({message: 'Student already exists'});
                        ok=false;
                    }
                });
                if(ok==true)
                {
                    app.locals.students.push({name:req.body.name,surname:req.body.surname,age:req.body.age});
                    res.status(201).json({message: 'Created'});
                }
            }
        }
        else
        {
            res.status(500).json({message: 'Invalid body format'});
        }
    }
});

module.exports = app;

Stefi Rest V9 5/5
#Subiect 3
#Tematica: REST

# Avand urmatoa aplicatie dezvoltata in NodeJS, sa se completeze metoda de tip `POST` de pe calea `/cars` :

- Daca nu exista body pentru cererea http, trebuie sa returnati un JSON cu urmatorul format: `{message: "Body is missing"}`. Codul de raspuns trebuie sa fie: `500`;
- Daca body-ul nu respecta formatul unei masini, trebuie sa returnati un JSON cu urmatorul format: `{message: "Invlid body format"}`. Codul de raspuns trebuie sa fie: `500`;
- Pretul unei masini trebuie sa fie mai mare ca 0.In caz contrar trebuie sa returnati un JSON cu urmatorul format: `{message: "Price should be a positive number"}`. Codul de raspuns trebuie sa fie: `500`; 
- Daca masina exista deja in vector, trebuie sa returnati un JSON cu urmatorul format: `{message: "Product already exists"}`.Codul de raspuns trebuie: `500`. Unicitatea se face in functie de model;
- Daca body-ul are formatul corespunzator, masina trebuie adaugata in vector si sa returnati un JSON cu urmatorul format: `{message: "Created"}`. Codul de raspuns trebuie sa fie: `201`;

const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');

const app = express();

app.use(bodyParser.json());
app.use(cors());

app.locals.cars = [
    {
        make: "BMW",
        model: "X6",
        price: 50000
    },
    {
        make: "Lamborghini",
        model: "Huracan",
        price: 200000
    },
];

app.get('/cars', (req, res) => {
    res.status(200).json(app.locals.cars);
});

app.post('/cars', (req, res, next) => {
    if(JSON.stringify(req.body)=="{}")
    {
        res.status(500).json({message:'Body is missing'});
    }
    else
    {
        if(req.body.make && req.body.model && req.body.price)
        {
            if(req.body.price<0)
            {
                res.status(500).json({message: 'Price should be a positive number'});
            }
            else
            {
                var ok=true;
                app.locals.cars.forEach(s=>{
                    if(s.model==req.body.model){
                        
                        res.status(500).json({message: 'Car already exists'});
                        ok=false;
                    }
                });
                if(ok==true)
                {
                    app.locals.cars.push({make:req.body.make,model:req.body.model,price:req.body.price});
                    res.status(201).json({message: 'Created'});
                }
            }
        }
        else
        {
            res.status(500).json({message: 'Invalid body format'});
        }
    }
})

module.exports = app;

Stefi Rest V10 3/5
#Subiect 3 (2.5 pts)
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metoda `POST` la adresa `/students`:

- DacÄƒ s-a trimis un request cu un corp gol sau nedefinit, se va returna un json cu urmÄƒtorul format: `{"message": "body is missing"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- DacÄƒ din corpul request-ului lipsesc proprietÄƒÈ›i se va returna un json cu urmÄƒtorul format: `{"message": "malformed request"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- VÃ¢rsta trebuie sÄƒ fie un numÄƒr pozitiv; Ã®n caz contrar se va returna un json cu urmÄƒtorul format: `{"message": "age should be a positive number"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- DacÄƒ studentul trimis prin corpul request-ului este valid, va fi adÄƒugat È™i se va returna un rÄƒspuns cu  codul `201`. Corpul rÄƒspunsului va fi `{"message": "created"}`;(0.5 pts)
- DacÄƒ se face un request `GET /students` corpul rÄƒspunsului trebuie sÄƒ conÈ›inÄƒ 11 `students`, inclusiv cel adÄƒugat anterior; (0.5 pts)

const express = require('express')
const bodyParser = require('body-parser')
const Sequelize = require('sequelize')

const mysql = require('mysql2/promise')

const DB_USERNAME = 'root'
const DB_PASSWORD = 'p@ss'

let conn

mysql.createConnection({
    user : DB_USERNAME,
    password : DB_PASSWORD
})
.then((connection) => {
    conn = connection
    return connection.query('CREATE DATABASE IF NOT EXISTS tw_exam')
})
.then(() => {
    return conn.end()
})
.catch((err) => {
    console.warn(err.stack)
})

const sequelize = new Sequelize('tw_exam', DB_USERNAME, DB_PASSWORD,{
    dialect : 'mysql',
    logging: false
})

let Student = sequelize.define('student', {
    name : Sequelize.STRING,
    address : Sequelize.STRING,
    age : Sequelize.INTEGER
},{
    timestamps : false
})

const app = express()
app.use(bodyParser.json())

app.get('/create', async (req, res) => {
    try{
        await sequelize.sync({force : true})
        for (let i = 0; i < 10; i++){
            let student = new Student({
                name : 'name ' + i,
                address : 'some address on ' + i + 'th street',
                age : 30 + i
            })
            await student.save()
        }
        res.status(201).json({message : 'created'})
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})
    }
})

app.get('/students', async (req, res) => {
    try{
        let students = await Student.findAll()
        res.status(200).json(students)
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})        
    }
})

app.post('/students', async (req, res) => {
     var obj = JSON.stringify(req.body);
    try{
       if(obj=='{}')
       {
            res.status(400).json({"message": "body is missing"});
       }
       else{
           
           if(req.body.age && req.body.name && req.body.address ) {
              if(req.body.age>0)
        {
                 Student.build(req.body).save().then(student => {
                    res.status(201).send({
                        message: "created"
                    });
                })
        }
        else
        {
            res.status(400).json({message:"age should be a positive number"})
        }
            } 
            else{
               res.status(400).json({"message": "malformed request"}); 
            
               
            }
       }
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})        
    }
})

module.exports = app

Stefi Rest V11 2/5
#Subiect 3 (2.5 pts)
#TOPIC: REST

# DatÄƒ fiind aplicaÈ›ia `app` completaÈ›i metoda `PUT` la adresa `/students/:id`:

- DacÄƒ s-a trimis un request cu un corp gol sau nedifinit, se va returna un json cu urmÄƒtorul format: `{"message": "body is missing"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- DacÄƒ din corpul request-ului lipsesc proprietÄƒÈ›i se va returna un json cu urmÄƒtorul format: `{"message": "malformed request"}`. Codul de rÄƒspuns va fi: `400`; (0.5 pts)
- Un student inexistent nu poate fi modificat. DacÄƒ se cere modificarea unui student inexistent se va returna un mesaj cu formatul: `{"message": "not found"}`. Codul de rÄƒspuns va fi: `404`; (0.5 pts)
- DacÄƒ studentul existÄƒ È™i corpul request-ului este valid, va fi modificat È™i se va returna un rÄƒspuns cu  codul `202`. Corpul rÄƒspunsului va fi `{"message": "accepted"}`;(0.5 pts)
- DacÄƒ se face un request `GET /students` corpul rÄƒspunsului trebuie sÄƒ conÈ›inÄƒ 10 `students`, inclusiv cel modificat anterior; (0.5 pts)


const express = require('express')
const bodyParser = require('body-parser')
const Sequelize = require('sequelize')

const mysql = require('mysql2/promise')

const DB_USERNAME = 'root'
const DB_PASSWORD = 'p@ss'

let conn

mysql.createConnection({
    user : DB_USERNAME,
    password : DB_PASSWORD
})
.then((connection) => {
    conn = connection
    return connection.query('CREATE DATABASE IF NOT EXISTS tw_exam')
})
.then(() => {
    return conn.end()
})
.catch((err) => {
    console.warn(err.stack)
})

const sequelize = new Sequelize('tw_exam', DB_USERNAME, DB_PASSWORD,{
    dialect : 'mysql',
    logging: false
})

let Student = sequelize.define('student', {
    name : Sequelize.STRING,
    address : Sequelize.STRING,
    age : Sequelize.INTEGER
},{
    timestamps : false
})

const app = express()
app.use(bodyParser.json())

app.get('/create', async (req, res) => {
    try{
        await sequelize.sync({force : true})
        for (let i = 0; i < 10; i++){
            let student = new Student({
                name : 'name ' + i,
                address : 'some address on ' + i + 'th street',
                age : 30 + i
            })
            await student.save()
        }
        res.status(201).json({message : 'created'})
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})
    }
})

app.get('/students', async (req, res) => {
    try{
        let students = await Student.findAll()
        res.status(200).json(students)
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})        
    }
})

app.put('/students/:id', async (req, res) => {
   var obj = JSON.stringify(req.body);
    try{
      
       if(obj=='{}')
       {
            res.status(400).json({"message": "body is missing"});
       }
       else{
           
           if(req.body.age && req.body.name && req.body.address ) {
             let student = await Student.findByPk(req.params.id)
                if (student){
                    await student.update(req.body)
                res.status(202).json({message : "accepted"})
        }
        else{
            res.status(404).json({message :  "not found"})
        }
            } 
            else{
               res.status(400).json({"message": "malformed request"}); 
            
               
            }
       }
    
    }
    catch(err){
        console.warn(err.stack)
        res.status(500).json({message : 'server error'})        
    }
})

module.exports = app

SERVICII SIMPLE
Alice Sau Ana Simple v2 5/5	 (este si Stefi v2 dar e 4/5)
# Subiect 1 (2.5 pts)		5/5
# Tematica: ClienÈ›i È™i servere simple

# Dat fiind serverul `server.js` È™i fiÈ™ierul `index.html` din directorul `public` directory:

# SatisfaceÈ›i urmÄƒtoarele cerinÈ›e:
- fiÈ™ierul `index.html`, care conÈ›ine textul `A simple app` este livrat de server ca conÈ›inut static (0.5 pts);
- butonul cu id-ul `del` existÄƒ Ã®n paginÄƒ È™i se poate da click pe el(0.5 pts);
- la Ã®ncÄƒrcarea paginii sunt Ã®ncÄƒrcate toate elementele Ã®n tabelul cu id `main` cu un `tr` pentru fiecare (0.5 pts);
- cÃ¢nd se dÄƒ click pe butonul `del` se È™terg elementele cu numele prezent Ã®n text input-ul cu id-ul `name` (0.5 pts);
- elementele cu numele selectat pentru È™tergere nu mai apar Ã®n tabel (0.5 pts);

const express = require('express')

const app = express()
app.use(express.static('public'))

app.locals.cars = [{
    name :  'a',
    color : 'red'
},{
    name :  'b',
    color : 'blue'
}]

app.get('/cars', (req, res) => {
    res.status(200).json(app.locals.cars)
})

app.delete('/cars/:name', (req, res) => {
    app.locals.cars = app.locals.cars.filter((e) => e.name !== req.params.name)
    res.status(202).json({message : 'accepted'}) 
})

module.exports = app

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A simple app</title>
    <script>
        window.onload = async () => {
            let btn = document.getElementById('del')
            let name = document.getElementById('name')

            btn.onclick = async () => {
                await deleteCar(name.value)
            }

            let deleteCar = async (name) => {
                try {
                    await fetch(`/cars/${name}`, {
                        method: 'delete'
                    }).then((response) => {
                        return response.json();
                    }).then(() => load());
                }
                catch (err) {
                    console.warn(err)
                }
            }

            let tbl = document.getElementById('main')

            let load = async () => {
                try {
                    let response = await fetch(`/cars`)
                    let data = await response.json()
                    let rows = data.map((e) => `
                        <tr>
                            <td>
                                ${e.name}
                            </td>
                            <td>
                                ${e.color}
                            </td>
                        </tr>
                    `)
                    console.warn(rows)
                    tbl.innerHTML = rows.join('')
                }
                catch (err) {
                    console.warn(err)
                }
            }
            load();
        }
    </script>
</head>

<body>
    A simple app
    <input type="text" placeholder="name" id="name" />
    <table id=main></table>
    <button id="del">Delete</button>
</body>

</html>

2) Var 3 Alice  sau Ana V3 3/5
# Subiect 1 (2.5 pts)
# Tematica: ClienÈ›i È™i servere simple

# Dat fiind serverul `app.js` È™i fiÈ™ierul `index.html` din directorul `public`:

# SatisfaceÈ›i urmÄƒtoarele cerinÈ›e:
- FiÈ™ierul `index.html`, trebuie sa contina un element de tip `paragraf` cu textul `Webtech app` si sa fie furnizat ca si continut static din directorul `public` (0.5 pts);
- Butoanele cu id-urile `load` si `delete` existÄƒ Ã®n paginÄƒ È™i nu se afla intr-o stare disabled (0.5 pts);
- La apasarea butonului `load` sunt Ã®ncÄƒrcate toate elementele din fisierul `data.json` Ã®n tabelul cu id `table` cu un `tr` pentru fiecare element si 3 `td-uri` pentru fiecare proprietate (0.5 pts);
- Input-ul de tip `text` cu id-ul `name` exista in pagina (0.5pts);
- La apasarea butonului `delete` se È™terg elementele cu numele prezent Ã®n text input-ul cu id-ul `name` (0.5 pts);

<!DOCTYPE html>
<html>

<head>
    <title>Webtech</title>
</head>

<body>
    <p>Webtech app</p>
    <table id="table"></table>
    <button id="load">load</button>
    <button id="delete">delete</button>
    <input type="text" id="name"></input>

    <script>
        window.onload = async () => {
            let btnload = document.getElementById('load')
            let btndelete = document.getElementById('delete')
            let tbl = document.getElementById('table')
            let name = document.getElementById('name')
            let people

            let getPeople = async () => {
                try {
                    const response = await fetch('../data.json');
                    const json = await response.json();
                    return json;
                }
                catch (err) {
                    console.log(err);
                }
            }

            btnload.addEventListener("click", async () => {
                try {
                    getPeople().then(data => {
                        people = data
                        let rows = data.map((e) => `
                            <tr>
                                <td>
                                    ${e.name}
                                </td>
                                <td>
                                    ${e.surname}
                                </td>
                                <td>
                                    ${e.age}
                                </td>
                            </tr>
                        `)
                        tbl.innerHTML = rows.join('')
                    })
                }
                catch (err) {
                    console.warn(err)
                }
            })

            btndelete.addEventListener("click", async () => {
                if (people) {
                    people = people.filter(e => e.name !== name.value)
                    let rows = people.map((e) => `
                            <tr>
                                <td>
                                    ${e.name}
                                </td>
                                <td>
                                    ${e.surname}
                                </td>
                                <td>
                                    ${e.age}
                                </td>
                            </tr>
                        `)
                    console.warn(rows)
                    tbl.innerHTML = rows.join('')
                }
            })
        }
    </script>
</body>

</html>

const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
app.use(express.static('public'))

app.use(cors());

module.exports = app;

3) Examen Robert 5/5 sau Ana Simple V1 sau Andrei V1
# Subiect 1 (2.5 pts)
# Tematica: ClienÈ›i È™i servere simple

# Dat fiind serverul `server.js` È™i fiÈ™ierul `index.html` din directorul `public` directory:

# SatisfaceÈ›i urmÄƒtoarele cerinÈ›e:
- fiÈ™ierul `index.html`, care conÈ›ine textul `A simple app` este livrat de server ca conÈ›inut static (0.5 pts);
- butonul cu id-ul `reload` existÄƒ Ã®n paginÄƒ È™i se poate da click pe el(0.5 pts);
- cÃ¢nd se dÄƒ click pe butonul cu id-ul `reload` nimic in filtru, toate elementele sunt returnate (0.5 pts);
- cÃ¢nd se dÄƒ click pe butonul cu id-ul `reload` cu valoarea `red` in filtru, elementele roÈ™ii sunt returnate (0.5 pts);
- cÃ¢nd se dÄƒ click pe butonul cu id-ul `reload` cu o valoare in filtru care nu corespunde culorii niciunui element, este returnatÄƒ o listÄƒ vidÄƒ (0.5 pts);

const express = require('express')

const app = express()
app.use(express.static('public'))

app.get('/cars', (req, res) => {
    let filter = req.query.filter
    if (!filter){
        res.status(200).json([{
            name :  'a',
            color : 'red'
        },{
            name :  'b',
            color : 'blue'
        }])
    }
    else{
        res.status(200).json([{
            name :  'a',
            color : 'red'
        },{
            name :  'b',
            color : 'blue'
        }].filter((e) => e.color === filter))
    }
})

module.exports = app

<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A simple app</title>
    <script>
        window.onload = async () => {
            let btn = document.getElementById('reload')
            let filter = document.getElementById('filter')

            let tbl = document.getElementById('main')

            btn.addEventListener("click", () => {
                const filterValue = filter.value;
                load(filterValue);
            })

            let load = async (filter) => {
                try {
                    const response = await fetch(`http://localhost:8080/cars?filter=${filter}`);
                    const data = await response.json();
                    console.log(data)
                    if (data.length > 0) {
                        let rows = data.map((e) => `
                        <tr>
                            <td>
                                ${e.name}
                            </td>
                            <td>
                                ${e.color}
                            </td>
                        </tr>
                    `)
                        tbl.innerHTML = rows.join('')
                    } else
                        tbl.innerHTML = [];

                }
                catch (err) {
                    console.warn(err)
                }
            }
            load('')
        }
    </script>
</head>

<body>
    A simple app
    <input type="text" placeholder="filter" id="filter" />
    <table id=main></table>
    <button id="reload">Reload</button>
</body>

</html>

Sau 
Stefi Simple Var 1 5/5
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A simple app</title>
    
</head>
<body>
    A simple app
    <table id=main></table>
    <input type="text" id="filter" />
    <button id=reload></button>
</body>

<script>
    window.onload = async () => {
        let btn = document.getElementById('reload')
        let filter = document.getElementById('filter')
        let tbl = document.getElementById('main')

        const preluareDate =()=>{
            const getData = new XMLHttpRequest();
            getData.open('GET', 'http://localhost:8080/cars')

            getData.responseType = 'json'

            getData.onload =()=>{
                const myData = getData.response

                console.log(filter.value)

                if(filter.value.length == 0){
                    
                    for(let i=0;i<myData.length;i++){
                        let linie = document.createElement('tr')
                        
                        for(let element in myData[i]){
                            
                            let coloana = document.createElement('td')
                            coloana.innerText = myData[i][element]
                            linie.append(coloana)
                        }
                        tbl.append(linie)
                    }
                }
                else if(filter.value == 'red'){
                    for(let i=0;i<myData.length;i++){
                        if(myData[i]['color'] == 'red'){
                            let linie = document.createElement('tr')
                            
                            for(let element in myData[i]){
                                
                                let coloana = document.createElement('td')
                                coloana.innerText = myData[i][element]
                                linie.append(coloana)
                            }
                            tbl.append(linie)
                        }
                    }
                }
            }

            getData.send()
        }

        btn.addEventListener('click', preluareDate)
    }
</script>
</html>

4) Ana Simple V0 5/5 sau Andrei V0
# Subiect 1 (2.5 pts)
# Tematica: ClienÈ›i È™i servere simple

# Dat fiind serverul `app.js` È™i fiÈ™ierul `index.html` din directorul `public` directory:

# SatisfaceÈ›i urmÄƒtoarele cerinÈ›e:
- fiÈ™ierul `index.html`, care conÈ›ine textul `A simple app` este livrat de server ca conÈ›inut static (0.5 pts);
- butonul cu id-ul `load` existÄƒ Ã®n paginÄƒ È™i se poate da click pe el(0.5 pts);
- cÃ¢nd se dÄƒ click pe butonul cu id-ul `load` se cere lista de `cars` de pe server; maÈ™inile cu culoare `red` sunt Ã®ncÄƒrcate Ã®n tabelul cu id `main` cu un `tr` pentru fiecare (0.5 pts);
- tabelul conÈ›ine cÃ¢te un `tr` pentru fiecare maÈ™inÄƒ Ã®ncÄƒrcatÄƒ (0.5 pts);
- sunt afiÈ™ate doar maÈ™ini cu culoarea `red` (0.5 pts);


<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A simple app</title>
    <script>
        function clickBtn(){
            fetch('http://localhost:8080/cars').then(result =>result.json()).then(data =>{
                //console.log(data)
                let table = document.getElementById('main')

                for(let i=0;i<data.length;i++){
                    if(data[i].color === 'red'){
                        let tr = document.createElement('tr')
                        let td = document.createElement('td')

                        td.innerText = data[i].name
                        tr.append(td)
                        table.append(tr)
                    }
                }
            })

        }

        function app(){
            let btnLoad = document.getElementById('load')
            btnLoad.addEventListener('click', clickBtn)
        }

        document.addEventListener("DOMContentLoaded",app)
    </script>

</head>
<body>
    A simple app
    <table id="main"></table>
    <button id="load">LOAD</button>
</body>
</html>

const express = require('express')

const app = express()
app.use("/",express.static("./public"))

app.get('/cars', (req, res) => {
    res.status(200).json([{
        name :  'a',
        color : 'red'
    },{
        name :  'b',
        color : 'blue'
    }])
})

module.exports = app

5) Ana Simple V4 5/5
# Subiect 1 (2.5 pts)
# Tematica: ClienÈ›i È™i servere simple

# Dat fiind serverul `app.js` È™i fiÈ™ierul `index.html` din directorul `public` directory:

# SatisfaceÈ›i urmÄƒtoarele cerinÈ›e:
- fiÈ™ierul `index.html`, care conÈ›ine textul `A simple app` este livrat de server ca conÈ›inut static (0.5 pts);
- fiÈ™ierul `profil.json` livrat de catre server respecta structura descrisa in test (0.5 pts)
- pagina `index.html` conÈ›ine titlu de rang 1 cu textul `Profil Influencer` (0.5 pts)
- detaliile profiluli (name, instagram, youtube) sunt afisate in paragrafe separate in div-ul cu id=content (0.5 pts) 
- butonul convert afiseaza numarul de urmaritori pe instagram in milioane (ex: 5M); operatia se realizeaza doar pe client (0.5 pts)


Index.html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A simple app</title>
    <script>
            let load = async () => {
                try{
                    let response = await fetch(`/profile.json`)

                    let object = await response.json()
                    let content = ''
                    content+= `
                        <p id="p1"> ${object.name} </p>
                        <p id="p2"> ${object.instagram} </p>
                        <p id="p3"> ${object.youtube} </p>
                    `
                    document.getElementById("content").innerHTML = content;

                }
                catch(err){
                    console.warn(err)
                }
            }

            let convert = () => {
                let instagram = document.getElementById('p2').innerHTML
                document.getElementById("p2").innerHTML = instagram/10000000 + "M";
            }

            document.addEventListener('DOMContentLoaded', load)
    </script>
</head>
<body>
    <h1>Profil influencer</h1>
    A simple app
    <div id="content"></div>
    <input type="button" value="convert" id="convert" onclick="convert()" />
</body>
</html>

Profile.json
{
    "name": "influencer", 
    "instagram": 1000000, 
    "youtube": 2000000
}

